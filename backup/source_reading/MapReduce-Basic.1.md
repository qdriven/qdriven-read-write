---
title: MAPREDUCE PATTERNS, ALGORITHMS, AND USE CASES
date: 2018-06-21 23:13:12
tags:
  - MapReduce
  - Algorithm
  - Back2Basic
---

## Map Reduce Basic -1

A notes from [MAPREDUCE PATTERNS, ALGORITHMS, AND USE CASES](https://highlyscalable.wordpress.com/2012/02/01/mapreduce-patterns/https://highlyscalable.wordpress.com/2012/02/01/mapreduce-patterns/ss)

Follow picture demostrate the MR flow clearly:
![img](https://highlyscalable.files.wordpress.com/2012/02/map-reduce.png)

## Basic Map Reduce Pattern: Counting and Summing

Problem Statement:

- Many documents(10000+)
- Each Document is a set of term(word)
- Calculate a total number of occurences of each term in all documents
- Also it can be arbitrary function of the terms. like average response time of requests in all log file

Solution:;

- First Thought:

```java
class Mapper
   method Map(docid id, doc d)
      for all term t in doc d do
         Emit(term t, count 1)
 
class Reducer
   method Reduce(term t, counts [c1, c2,...])
      sum = 0
      for all count c in [c1, c2,...] do
          sum = sum + c
      Emit(term t, count sum)
```

- Fix the obvious disaadvantage of first thought:
decreasing the Mapper counts

```java
class Mapper
   method Map(docid id, doc d)
      H = new AssociativeArray
      for all term t in doc d do
          H{t} = H{t} + 1
      for all term t in H do
         Emit(term t, count H{t})
```

or add combiner to do combination:

```java
class Mapper
   method Map(docid id, doc d)
      for all term t in doc d do
         Emit(term t, count 1)
 
class Combiner
   method Combine(term t, [c1, c2,...])
      sum = 0
      for all count c in [c1, c2,...] do
          sum = sum + c
      Emit(term t, count sum)
 
class Reducer
   method Reduce(term t, counts [c1, c2,...])
      sum = 0
      for all count c in [c1, c2,...] do
          sum = sum + c
      Emit(term t, count sum)
```
This is Log Analysis, Data Querying

## Collating

Inverted Indexes, ETL

##  Filtering (“Grepping”), Parsing, and Validation

Text parsing and fillter by conditions Mapper take records one by one and emit accept items or transformed version, this is ```Log Analysis, Data Querying, ETL, Data Validation```

## Distributed Task Execution

Each Mapper takes specification,performs corresponding computations and emits results.Reducer combines all emmitted parts intoo final result.

## Case Study: Simulation of A Digital Communication System

- input: random data generated by system
- output: computes error probability of throughput

Each Mapper recieves the simulation for specified amount of data ,emit error rate.Reducer computes avaerage error rate.

- Sorting: composite keys, and emit values
- Using BigTable Concept


## Case Study: Iterative Message Passing(Graph Processing)

```java
class Mapper
   method Map(id n, object N)
      Emit(id n, object N)
      for all id m in N.OutgoingRelations do
         Emit(id m, message getMessage(N))
 
class Reducer
   method Reduce(id m, [s1, s2,...])
      M = null
      messages = []
      for all s in [s1, s2,...] do
          if IsObject(s) then
             M = s
          else               // s is a message
             messages.add(s)
      M.State = calculateState(messages)
      Emit(id m, item M)
```

![img](https://highlyscalable.files.wordpress.com/2012/01/graph-propagation-3.png)

##  Case Study: Availability Propagation Through The Tree of Categories

```java
class N
   State in {True = 2, False = 1, null = 0}, initialized 1 or 2 for end-of-line categories, 0 otherwise
 
method getMessage(object N)
   return N.State
 
method calculateState(state s, data [d1, d2,...])
   return max( [d1, d2,...] )
```

## Case Study: Breadth-First Search

