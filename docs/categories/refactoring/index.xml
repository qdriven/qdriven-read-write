<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>refactoring on DirtyHands-Tester</title>
    <link>https://qdriven.github.io/categories/refactoring/</link>
    <description>Recent content in refactoring on DirtyHands-Tester</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>QDriven- All rights reserved</copyright>
    <lastBuildDate>Tue, 03 Nov 2015 10:31:11 +0000</lastBuildDate><atom:link href="https://qdriven.github.io/categories/refactoring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Refactoring-10-introduce method object, replace conditions with polymorphism</title>
      <link>https://qdriven.github.io/blog/tips/refactoring/2015-11-3-refactoring-introduce-method-object-and-replace-conditions-with-poly/</link>
      <pubDate>Tue, 03 Nov 2015 10:31:11 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/tips/refactoring/2015-11-3-refactoring-introduce-method-object-and-replace-conditions-with-poly/</guid>
      <description>将方法参数转化为类 有时一个方法的传入参数太多，就需要考虑是否需要引入新的类来解决的。
public class Registration { public void create(double amount,String name, double credits){ //do work  } } 重构后:</description>
    </item>
    
    <item>
      <title>Refactoring-8-remove God Class</title>
      <link>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-remove-god-class/</link>
      <pubDate>Tue, 03 Nov 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-remove-god-class/</guid>
      <description>God Class 就是一个类里面有一大堆不相干的方法放在一起,一般 情况下很多的工具类，或者manager有可能会有这样的情况.不是说不能有 工具类或者manager类，这个的关键是不相干的放在一个类里面。</description>
    </item>
    
    <item>
      <title>Refactoring-1-Encapsulate Collection</title>
      <link>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-encapsulatecollection/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-encapsulatecollection/</guid>
      <description>关于重构的第一篇，后续会在这个话题继续讨论
What is Encapsulate Collection In certain scenarios it is beneficial to not expose a full collection to consumers of a class.</description>
    </item>
    
    <item>
      <title>Refactoring-2-Move Method</title>
      <link>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-move-method/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-move-method/</guid>
      <description>Move Method 重构实际上比较简单，一个简单的描述就是:
 如果有一个方法在一个类里面出现的频率很高，但他不在这个类里面 那么Move Method就是把这个方法移动到出现频率高的这个类里面  Before Move Method public class BankAccountOrigin { private int accountAge; private int creditScore; private AccountInterestOrigin accountInterest; public double calculateInterestRate(){ if(creditScore&amp;gt;800){ return 0.</description>
    </item>
    
    <item>
      <title>Refactoring-3-Pull Up Method</title>
      <link>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-pull-up-method/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-pull-up-method/</guid>
      <description>Pull Up Method 顾名思义,就是把方法向上拉,向上拉是个什么意思呢?在面向 对象中向上就是向父类，或者接口拉,是不是很形象？</description>
    </item>
    
    <item>
      <title>Refactoring-4-Push Down Method and Pull Up and Posh Down Field</title>
      <link>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-pullupfield-pushdownfield/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-pullupfield-pushdownfield/</guid>
      <description>Push down method 和Pull Up method刚好相反.</description>
    </item>
    
    <item>
      <title>Refactoring-5-rename</title>
      <link>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-rename/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-rename/</guid>
      <description>rename也是一个重构方式，对的，你没有看错，他确实是个重构的方法. 不要小看了命名，命名不是个简单活哦，他背后可能包含了历史，人文，幽默， 风格，立场。。。。。。。， 起个让大部分人都懂的名字可不是个容易活。</description>
    </item>
    
    <item>
      <title>Refactoring-6-Replace Inheritance with Delegation</title>
      <link>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-replace-inheritance-with-delegation/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-replace-inheritance-with-delegation/</guid>
      <description>Replace Inheritance with Delegation, 这种重构方式主要是继承有时 看起来不是那么合理，同时继承可能让程序的扩展性不好，所以可以改用委托 或者组合的形式重构。</description>
    </item>
    
    <item>
      <title>Refactoring-7-Extract-Interface,Method,Sub Class,Supper Class</title>
      <link>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-extract-interface-method/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/tips/refactoring/2015-10-26-refactoring-extract-interface-method/</guid>
      <description>Extract-Interface,Method,Sub Class,Supper Class
以上重构的方式主要是通过提起接口,方法,为了让代码有更好的可读性,可测性.
开始:实例代码 以下是一个需要重构的实例代码：</description>
    </item>
    
  </channel>
</rss>
